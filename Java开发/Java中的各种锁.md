# Java中的各种锁

# 1.引言

Java中的主流锁分类

>线程要不要锁住同步资源

- 锁住： **悲观锁**
- 不锁柱：**乐观锁**

> 锁住同步资源失败，线程要不要阻塞

- 阻塞：
- 不阻塞：自旋锁 和适应性自旋锁

> 多个线程竞争同步资源时，锁的变化

- **无锁**：不锁住资源，多个线程只有一个能成功修改资源，其他线程将重试。
- **偏向锁**：同一个线程获取同步资源时会自动获取资源
- **轻量级锁**：多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放
- **重量级锁**：多个线程竞争同步资源，没有获取资源的线程阻塞等待唤醒

> 多个线程竞争资源时要不要排队

- 排队：公平锁
- 先尝试插队，插队失败再排队：非公平锁

> 一个线程中的多个流程能不能获取同一把锁

- 能：可重入锁
- 不能：不可重入锁

> 多个线程能不能共享一把锁

- 能：共享锁

- 不能：排他锁

# 2. 乐观锁 vs 悲观锁

乐观锁与悲观锁是一种广义上的概念，再Java和数据库中都有此概念对应的实际应用

## 2.1概念

**悲观锁**：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在读取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized 和Lock的实现都是悲观锁。

**乐观锁**：对于同一个数据的并发操作，乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据时去判断之前有没有别的线程更新了这个数据，如果这个数据没有更新，当前线程将自己修改的数据写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作。Java中采用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就是通过CAS自旋实现的。

## 2.2 应用场景

从概念上可以看到：

- **悲观锁**更适合写操作比较多的场景，先加锁可以保证写操作时数据的正确
- **乐观锁**更适合读操作比较多的场景，不加锁的特点能够提高读取数据的速度。

## 2.3 例子

```java
public class Solution {
//    ------------悲观锁的调用方式
    //synchronized
    public synchronized void testMethod(){
        // 操作同步资源
    }
    //ReentrantLock
    private ReentrantLock lock = new ReentrantLock();
    public void modifyResource(){
        lock.lock();
        //处理同步资源
        lock.unlock();
    }
//    ----------乐观锁的调用方式 CAS
    private AtomicInteger atomicInteger = new AtomicInteger();
    public void positiveLock(){
        atomicInteger.incrementAndGet();//执行自增1        
    }
}
```

通过调用方式的示例，可以发现悲观锁基本上都是显示的锁定资源后再操作同步资源，乐观锁则直接去操作同步资源。

>  CAS

CAS全称Compare And Swap，比较与交换，是一种无锁算法，在不适用锁(没有线程阻塞)的情况下实现多线程之间的变量同步，`java.util.concurrent`包中的原子类就是用过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

- 需要读写的内存值V
- 进行比较的值A
- 要写入的新值B

当且仅当V的值等于A时(检查内存的值和当前读取的值是否一样)，CAS通过原子方式用B来更新V的值（比较+更新整体是一个原子操作），否则不会执行任何操作，一般情况下“更新”是一个不断重试的操作。

CAS虽然高效，但是存在三大问题：

1. **ABA问题**。CAS需要在操作值得时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存的值原来是A，后来变为B，然后又变为A，那么通过CAS进行检查时会发现值没有发生变化。但是实际上是有变化的，ABA问题的解决思路是在变量前面加上版本号，每一次变量更新的时候就把版本号加一
2. **循环时间长开销大**。CAS操作如果长时间不成功，则会导致一直自旋
3. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对于多个共享变量，CAS是无法保证操作的原子性的

# 3. 自旋锁 vs 自适应自旋锁

阻塞或唤醒一个java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间，**如果同步代码块中的内容过于简单**，状态转换消耗的时间有可能比用户代码执行的时间还要长。

在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换进程，进程挂起和恢复的花销可能让系统得不偿失。如果机器上有多个处理器，能够让两个或者两个以上的线程同时并行处理，就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。（换句话说，就是循环等待，但是CPU一直在执行）

为了让当前线程“稍等一下”，需要让当前线程进行自旋，如果前面锁定的同步资源的线程已经释放了锁，那么当前线程就不必自旋，从而直接获取同步资源，避免切换线程带来的开销。这就是**自旋锁**

自旋锁本身是有缺点的，它不能代替阻塞，自旋等待虽然谜面了线程切换的开销，但是它占用了CPU的时间，如果锁被占用的时间很短，自旋等待的效果非常好，但是如果锁被占的时间很长，那么自旋的线程会浪费处理器资源。

所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数，没有成功获得锁，就挂起线程。

**自适应自旋锁**以为这自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

如果在同一个锁对象上，自旋等待成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待的时间相对更长。

如果对于某个锁，自旋很少成功获得，那在以后尝试获取这个锁时可能自动省略掉自旋过程，直接阻塞线程，避免浪费CPU资源。

# 4. 无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁

这四种锁是指锁的状态，专门针对`synchronized`关键字的。在介绍这四种锁状态之间还需要介绍一些额外的知识

## 4.1 Java对象头 和 Monitor

### 4.1.1 Java对象头

`synchronized`是悲观锁，在操作同步资源之前需要给同步资源上锁，这个锁就存储在Java对象头中。 以`Hotspot`虚拟机为例， `Hotspot`的对象头主要包括两部分数据：`Mark Word`（标记字段）、`Class Pointer`（类型指针）

> **Mark Word**

默认存储对象的`HashCode`，分代年龄和锁标志位信息。**这些信息都是与对象自身定义无关的数据**，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。

> **Class Point**

虚拟机通过这个指针来确定这个对象是哪个类的实例。

### 4.1.2 Monitor

`Monitor`可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者`Monitor`锁。

`Monitor`是线程私有的数据结构，每一个线程都有一个可用`monitor record`列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个`monitor`关联, `monitor`中有一个`Owner`字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的`Mutex Lock`（互斥锁）来实现的线程同步

如同在**自旋锁**中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。

这种依赖于操作系统`Mutex Lock`所实现的锁我们称之为“**重量级锁**”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“**偏向锁**”和“**轻量级锁**”。

所以，目前锁一共有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。这四种锁状态对应的`Mark Word`内容为：

| 锁状态   | 存储变量                                            | 存储内容 |
| -------- | --------------------------------------------------- | -------- |
| 无锁     | 对象的hashCode， 对象的分代年龄，是否是偏向锁       | 01       |
| 偏向锁   | 偏向线程ID， 偏向时间戳，对象分代年龄，是否是偏向锁 | 01       |
| 轻量级锁 | 指向栈中锁记录的指针                                | 00       |
| 重量级锁 | 指向互斥量的指针                                    | 10       |

## 4. 2 无锁 CAS

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 

**无锁的特点**就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。

## 4.3 偏向锁

偏向锁是指同一段同步代码一直被一个线程访问，那么该线程会自动获取锁，降低获取锁的代价。

如果锁总是由同一线程多次获得，不存在多线程竞争，那么就可以使用偏向锁。 此时同步资源的对象头重，`Mark Word`里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁， 而是检测Mark Word里是否存储着指向当前线程的偏向锁。

> 作用

引入偏向锁是为了在没有多线程竞争的情况下减少不必要的加锁和解锁(CAS操作)。偏向锁只需在置换ThreadID时候依赖依次CAS原子指令即可

只有遇到其他线程尝试竞争同步资源时，持有偏向锁的线程才会释放锁，然后撤销偏向锁。线程不会主动释放偏向锁，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

> 启动

偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：`-XX:-UseBiasedLocking=false`，关闭之后程序默认会进入轻量级锁状态。

## 4.4 轻量级锁

是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，将同步资源中的Mark Word复制到当前线程的锁记录中。

拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

## 4.5 重量级锁

升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

> 综上，偏向锁通过对比同步资源中的Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

# 5. 公平锁 VS 非公平锁

## 5.1 概念

**1. 公平锁**是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。

- 公平锁的优点是等待锁的线程不会饿死。
- 缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

**2. 非公平锁**是多个线程加锁时直接尝试获取锁，获取不到才会到队尾等待。但如果所需要的锁刚好可用(**插队**)，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。

- 非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。
- 缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

> 综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，获取失败后，再去排队，所以存在后申请却先获得锁的情况。

## 5.2 代码实现

> 公平锁 

> 非公平锁

# 5. 可重入锁

可重入锁又名递归锁，是指在同一个线程外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。Java中`ReentrantLock`和`synchronized`都是可重入锁。

```java
class Solution {
    static final Object obj = new Object();
    public void m1(){
        new Thread(()->{
            synchronized (obj){
                System.out.println("外层调用");
                synchronized (obj){
                    System.out.println("中层调用");
                    synchronized (obj){
                        System.out.println("内层调用");
                    }
                }
            }
        }).start();
    }
    public static void main(String[] args) throws Exception{
        Solution s = new Solution();
        s.m1();
    }
}
```

内部方法锁住obj不会因为外层没有释放obj对象而照成死锁。

可重入锁的一个优点是可一定程度避免死锁。

# 6. 独享锁 VS 共享锁

**独享锁**也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。

**共享锁**是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。

独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。